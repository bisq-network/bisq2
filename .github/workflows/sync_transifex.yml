name: Transifex

on:
  pull_request:
    types: [ opened, synchronize, reopened ]
    paths:
      - '.tx/config'
      - 'i18n/src/main/resources/**.properties'
  workflow_run:
    workflows: [ Build Bisq 2 ]
    types: [ completed ]

jobs:
  verify:
    name: Verify Transifex configuration
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.event.workflow_run.head_sha }}

      - name: Verify that .tx/config is in sync with the i18n folder
        run: |
          set -euo pipefail

          # Extract source files from .tx/config, trimming whitespace and de-duplicating
          config_files=$(grep -E '^[[:space:]]*source_file' .tx/config \
            | sed 's/.*= *//' \
            | sed 's|i18n/src/main/resources/||' \
            | sort -u)

          # Get actual source files from i18n directory (excluding locale-specific files)
          i18n_files=$(find i18n/src/main/resources -maxdepth 1 -name "*.properties" \
            | grep -v -E '(_[a-z]{2}(-[A-Z][a-z]+)?(([_-]([A-Z]{2}|[0-9]{3})))?|_pcm)\.properties$' \
            | sed 's|i18n/src/main/resources/||' \
            | sort -u)

          if [ "$config_files" != "$i18n_files" ]; then
            echo "::error::.tx/config is out of sync with i18n/src/main/resources/"
            echo "Please run the following command and commit the changes:"
            echo "./gradlew apps:desktop:i18n:updateTxConfig"
            diff -u <(echo "$config_files") <(echo "$i18n_files")
            exit 1
          fi
          echo ".tx/config is in sync with i18n/src/main/resources/"

  calculate_and_push_sources:
    name: Calculate pushes and push source files
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'
    needs: verify
    runs-on: ubuntu-latest
    outputs:
      t_matrix: ${{ steps.calculate-pushes.outputs.t_matrix || '{"include":[]}' }}
      has_translation_changes: ${{ steps.calculate-pushes.outputs.has_translation_changes }}
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0

      - name: Check if the commit is in the main branch
        id: check_commit
        run: |
          git fetch origin main
          if git merge-base --is-ancestor ${{ github.event.workflow_run.head_sha }} origin/main; then
            echo "commit_in_main=true" >> $GITHUB_OUTPUT
          else
            echo "commit_in_main=false" >> $GITHUB_OUTPUT
          fi

      - name: "Check if TX_TOKEN secret exists"
        if: steps.check_commit.outputs.commit_in_main == 'true'
        env:
          transifex_secret: ${{ secrets.TX_TOKEN }}
        run: |
          if [ -z "$transifex_secret" ]; then
            echo "The secret \"TX_TOKEN\" has not been set; please go to \"settings > secrets and variables\" to create it"
            exit 1
          fi

      - name: Validate Python script exists
        if: steps.check_commit.outputs.commit_in_main == 'true'
        run: |
          if [ ! -f scripts/generate_transifex_batches.py ]; then
            echo "::error::Required script not found: scripts/generate_transifex_batches.py"
            exit 1
          fi
          echo "::notice::Batch generation script validated"

      - name: Calculate push commands
        id: calculate-pushes
        if: steps.check_commit.outputs.commit_in_main == 'true'
        run: |
          set -euo pipefail

          echo "Finding changed files..."
          # We compare the merge commit with its first parent to get the list of files.
          # Note: This is reliable for standard PR merges but may not handle octopus merges.
          CHANGED_FILES=$(git diff --name-only ${{ github.event.workflow_run.head_sha }}~1 ${{ github.event.workflow_run.head_sha }})
          echo "Files changed in the merge:"
          echo "$CHANGED_FILES"

          # --- Handle SOURCE file pushes (-s) ---
          s_args=""
          if echo "${CHANGED_FILES}" | grep -q -x ".tx/config"; then
            echo "::notice:: .tx/config changed. Pushing all source files."
            s_args="push -s"
          else
            s_resources="" # This will be the comma-separated list
            CHANGED_SOURCE_FILES=$(echo "${CHANGED_FILES}" | grep -E '\.properties$' | grep -v -E '(_[a-z]{2}(-[A-Z][a-z]+)?(([_-]([A-Z]{2}|[0-9]{3})))?|_pcm)\.properties$' -- || true)
            if [ -n "$CHANGED_SOURCE_FILES" ]; then
              for file in $CHANGED_SOURCE_FILES; do
                resource_slug_line=$(awk -v file="$file" '
                  $0 ~ /^\[o:.*:p:.*:r:.*\]$/ {resource=$0}
                  $0 ~ ("source_file[[:space:]]*=[[:space:]]*" file "$") {print resource}
                ' .tx/config)
                if [[ -n "$resource_slug_line" ]] && [[ "$resource_slug_line" =~ ^\[o:.*:p:(.*):r:(.*)\]$ ]]; then
                  project_slug="${BASH_REMATCH[1]}"
                  resource_slug="${BASH_REMATCH[2]}"
                  full_resource_id="${project_slug}.${resource_slug}"
                  if [[ -z "$s_resources" ]]; then
                      s_resources="$full_resource_id"
                  else
                      s_resources+=",$full_resource_id"
                  fi
                else
                  echo "::warning::Could not find resource slug for changed source file: $file"
                fi
              done
            fi
            # If we found any resources, construct the final args string
            if [[ -n "$s_resources" ]]; then
              s_args="push -s -r $s_resources"
            fi
          fi
          echo "s_args=$s_args" >> $GITHUB_OUTPUT

          # --- Handle TRANSLATION file pushes (-t) with BATCHING ---
          # Collect all changed locales and their resources
          declare -A lang_resources
          CHANGED_TRANSLATION_FILES=$(echo "${CHANGED_FILES}" | grep -E 'i18n/src/main/resources/.*\.properties$' | grep -E '(_[a-z]{2}(-[A-Z][a-z]+)?(([_-]([A-Z]{2}|[0-9]{3})))?|_pcm)\.properties$' -- || true)

          if [ -n "$CHANGED_TRANSLATION_FILES" ]; then
            for file in $CHANGED_TRANSLATION_FILES; do
              lang=$(echo "$file" | sed -E 's/.*_([a-z]{2}(-[A-Z][a-z]+)?(([_-]([A-Z]{2}|[0-9]{3})))?|pcm)\.properties$/\1/')
              resource_slug_line=$(awk -v file="$file" -v lang="$lang" '
                BEGIN{FS="="}
                $0 ~ /^\[o:.*:p:.*:r:.*\]$/ {resource=$0}
                $1 ~ /^[[:space:]]*file_filter/ {
                    filter_path=$2;
                    gsub(/^[[:space:]]+|[[:space:]]+$/, "", filter_path);
                    gsub(/<lang>/, lang, filter_path);
                    if (filter_path == file) {
                        print resource;
                        exit;
                    }
                }
              ' .tx/config)
              if [[ -n "$resource_slug_line" ]] && [[ "$resource_slug_line" =~ ^\[o:.*:p:(.*):r:(.*)\]$ ]]; then
                project_slug="${BASH_REMATCH[1]}"
                resource_slug="${BASH_REMATCH[2]}"
                full_resource_id="${project_slug}.${resource_slug}"
                if [[ ! -v lang_resources[$lang] ]]; then
                    lang_resources[$lang]="$full_resource_id"
                else
                    lang_resources[$lang]+=",$full_resource_id"
                fi
              fi
            done

            # Build resources JSON for Python script
            # Convert bash associative array to JSON format
            resources_json="{"
            first_item=true
            for locale in "${!lang_resources[@]}"; do
              if ! $first_item; then
                resources_json+=","
              fi
              # Escape quotes in resource values
              resources="${lang_resources[$locale]}"
              resources_json+="\"$locale\":\"$resources\""
              first_item=false
            done
            resources_json+="}"

            # Collect changed locales for batch generation
            changed_locales_list=""
            for locale in "${!lang_resources[@]}"; do
              changed_locales_list="${changed_locales_list:+$changed_locales_list,}$locale"
            done

            # Generate batched matrix configuration if we have locales
            if [ -n "$changed_locales_list" ]; then
              echo "has_translation_changes=true" >> $GITHUB_OUTPUT
              echo "::notice::Changed locales: $changed_locales_list"
              echo "::notice::Resources mapping: $resources_json"

              # Call Python script with resources mapping for complete JSON generation
              # This eliminates all bash JSON manipulation and deduplicates resources properly
              batch_matrix=$(python3 scripts/generate_transifex_batches.py \
                --locales "$changed_locales_list" \
                --batch-size 4 \
                --max-parallel 2 \
                --json \
                --resources-json "$resources_json")

              echo "::notice::Generated batch configuration: $batch_matrix"
              printf 't_matrix=%s\n' "$batch_matrix" >> "$GITHUB_OUTPUT"
            else
              echo "has_translation_changes=false" >> $GITHUB_OUTPUT
              echo 't_matrix={"include":[]}' >> "$GITHUB_OUTPUT"
            fi
          else
            echo "has_translation_changes=false" >> $GITHUB_OUTPUT
            echo 't_matrix={"include":[]}' >> "$GITHUB_OUTPUT"
          fi

      - name: Push source files to Transifex
        if: steps.calculate-pushes.outputs.s_args != ''
        uses: transifex/cli-action@v2
        with:
          token: ${{ secrets.TX_TOKEN }}
          args: ${{ steps.calculate-pushes.outputs.s_args }}

  push_translations:
    name: Push translations (${{ matrix.name }})
    if: needs.calculate_and_push_sources.outputs.t_matrix != '{"include":[]}'
    needs: calculate_and_push_sources
    runs-on: ubuntu-latest
    # PHASE 1: Dynamic batching with controlled parallelism
    # Batches are generated dynamically based on changed locales only
    # Uses scripts/generate_transifex_batches.py for optimal batch configuration
    strategy:
      matrix: ${{ fromJson(needs.calculate_and_push_sources.outputs.t_matrix) }}
      max-parallel: 2  # Only 2 batches at a time (136 max concurrent API calls)
      fail-fast: false  # Don't cancel all jobs if one fails
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      # Install Transifex CLI for direct tx commands in retry/verification steps
      - name: Install Transifex CLI
        run: |
          curl -o- https://raw.githubusercontent.com/transifex/cli/master/install.sh | bash
          # Add to PATH for subsequent steps (takes effect in next step, not current)
          echo "$PWD" >> $GITHUB_PATH
          # Verify installation using full path
          ./tx --version
        env:
          TX_TOKEN: ${{ secrets.TX_TOKEN }}

      # Validate matrix resources field
      - name: Validate batch configuration
        run: |
          if [ -z "${{ matrix.resources }}" ]; then
            echo "::error::No resources specified for batch ${{ matrix.id }} (locales: ${{ matrix.locales }})"
            echo "::error::This indicates a bug in the batch generation script"
            exit 1
          fi
          echo "::notice::Batch ${{ matrix.id }} validated: ${{ matrix.locales }} â†’ ${{ matrix.resources }}"

      # PHASE 1: Stagger batch starts to prevent API overload
      - name: Stagger batch start
        run: |
          # Add delay based on batch ID to prevent simultaneous starts
          DELAY=$(((${{ matrix.id }} - 1) * 10))
          echo "::notice::Delaying batch ${{ matrix.id }} by ${DELAY}s for rate limiting"
          sleep $DELAY

      # PHASE 1: Retry logic with exponential backoff
      - name: Push ${{ matrix.name }} translations with retry
        uses: nick-fields/retry@v3
        id: push_with_retry
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_wait_seconds: 15
          exponential_backoff: true
          retry_on: error
          command: |
            set -euo pipefail

            echo "::group::Uploading translations for batch: ${{ matrix.locales }}"

            # Split batch locales and upload with inter-locale delay
            IFS=',' read -ra LOCALES <<< "${{ matrix.locales }}"
            UPLOADED_COUNT=0

            for locale in "${LOCALES[@]}"; do
              echo "::notice::Uploading locale: $locale"

              # Rate limiting: 5s delay between locales within batch
              if [ $UPLOADED_COUNT -gt 0 ]; then
                echo "::notice::Rate limiting: sleeping 5s between locales"
                sleep 5
              fi

              # Capture full output for error diagnosis
              EXIT_CODE=0
              OUTPUT=$(tx push -t -l "$locale" -r "${{ matrix.resources }}" 2>&1) || EXIT_CODE=$?

              if [ ${EXIT_CODE:-0} -ne 0 ]; then
                echo "$OUTPUT"

                # Distinguish permanent vs transient errors
                if echo "$OUTPUT" | grep -qi "unauthorized\|forbidden\|not found\|invalid"; then
                  echo "::error::Permanent error for $locale - no retry"
                  echo "::error::$OUTPUT"
                  exit 1  # Don't retry permanent errors
                elif echo "$OUTPUT" | grep -qi "timeout\|rate limit\|too many requests\|connection\|network"; then
                  echo "::warning::Transient error for $locale - will retry"
                  echo "::warning::$OUTPUT"
                  exit 2  # Retry transient errors
                else
                  echo "::warning::Unknown error for $locale - will retry once"
                  echo "::warning::$OUTPUT"
                  exit 2
                fi
              fi

              echo "âœ… Upload successful: $locale"
              ((UPLOADED_COUNT++))
            done

            echo "::endgroup::"
            echo "::notice::Batch ${{ matrix.name }} complete: ${UPLOADED_COUNT} locales uploaded"

      # PHASE 1: Upload verification
      - name: Verify upload succeeded
        id: verify
        if: steps.push_with_retry.outcome == 'success'
        run: |
          # Wait for Transifex propagation (eventual consistency)
          # Increased from 10s to 15s based on review feedback
          echo "::notice::Waiting 15 seconds for Transifex to process uploads..."
          sleep 15

          echo "::group::Verifying uploads for batch: ${{ matrix.locales }}"

          IFS=',' read -ra LOCALES <<< "${{ matrix.locales }}"
          VERIFICATION_FAILED=false

          for locale in "${LOCALES[@]}"; do
            echo "Verifying $locale..."

            # Pull back what we just pushed (dry-run to avoid downloading)
            # Retry verification up to 3 times with delay for Transifex propagation
            VERIFIED=false
            for attempt in {1..3}; do
              # Check exit code first, then verify output as secondary check
              EXIT_CODE=0
              OUTPUT=$(tx pull -l "$locale" -r "${{ matrix.resources }}" --mode onlytranslated --dry-run 2>&1) || EXIT_CODE=$?

              if [ $EXIT_CODE -eq 0 ] && echo "$OUTPUT" | grep -q "Pulling"; then
                echo "âœ… Verified: $locale exists in Transifex (attempt $attempt)"
                VERIFIED=true
                break
              else
                if [ $attempt -lt 3 ]; then
                  echo "::notice::Verification attempt $attempt failed for $locale (exit: $EXIT_CODE), retrying in 5s..."
                  sleep 5
                fi
              fi
            done

            if ! $VERIFIED; then
              echo "::warning::Verification FAILED for $locale after 3 attempts - not found in Transifex"
              VERIFICATION_FAILED=true
            fi
          done

          echo "::endgroup::"

          if [ "$VERIFICATION_FAILED" = true ]; then
            echo "::error::Some translations failed verification"
            echo "::error::Uploaded files may not be in Transifex - manual investigation required"
            exit 1
          fi

      # Report metrics for monitoring
      - name: Report upload metrics
        if: always()
        run: |
          echo "## ðŸŒ Batch ${{ matrix.name }} Upload Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Batch ID**: ${{ matrix.id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Locales**: ${{ matrix.locales }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ steps.push_with_retry.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Verification**: ${{ steps.verify.outcome || 'skipped' }}" >> $GITHUB_STEP_SUMMARY

  # Summary job to aggregate results
  summary:
    name: Upload Summary Report
    needs: [calculate_and_push_sources, push_translations]
    if: always() && needs.calculate_and_push_sources.outputs.has_translation_changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        run: |
          echo "# ðŸŒ Translation Upload Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Note: In GitHub Actions, we can't easily aggregate matrix job results
          # This is a placeholder for future monitoring enhancements
          echo "Translation upload workflow completed." >> $GITHUB_STEP_SUMMARY
          echo "Check individual batch job logs for detailed status." >> $GITHUB_STEP_SUMMARY
